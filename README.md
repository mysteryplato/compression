# compression
图像压缩算法

/*
实现一个图像压缩的算法（这里需要前提介绍下图像的基础知识: 8位灰度图像，bitmap,png,jpg）
- 1.创建1000个float数组，长度从2048到5000随机生成，数据范围从0.00-5000.00随机生成,
    生成数据和压缩过程使用for循环，使用数组指针，在堆上创建
- 2.遍历所有的数组,判断数组长度:
    如果长度>4096,直接压缩;
    如果长度<4096,那么需要和其他长度小于<4096的数组压缩到到同一个新创建的byte数组中;
    新创建的byte数组长度至少为4096
    一个byte数组可以存放多个float数组的数据，但是一个float数组只能放在一个byte数组
- 3.byte数组需要先设置表头:表头的定义如下：
    3.1 第1个Byte：压缩的float数组的个数,如果该byte数组包含了1个float数组的数据，
        那么就是1;如果包含了2个，那么就为2
    3.2 第2,3个Byte：第一个数组的长度
    3.3 往后w*h个byte：float数组每一个数据转化成一个byte，转换方式见4说明
    3.4 如果存多个数据，依次往后按照这样的格式存
- 4.float数组中每一个高度的小数部分去除，整数部分按照其最大值和最小值的范围映射到[0,255]
- 5.获取到的byte数组保存为文件，文件名按照压缩的元件名，如压缩了一个chip001的数组就是
    chip001,如果是chip001和chip002就是chip001_chip002
- 6.读取保存的文件，按照同样的规则把高度从byte解析到float数组
- 7.统计压缩和解压缩的时间
- 8.将解压出的数组的数据和float数组的数据的差值保存名字为“chipxxxdiff”格式的文件中
注意:
- 1.整个过程注意内存泄漏问题
- 2.数据的生成，压缩，导出，解压都封装成函数
*/
